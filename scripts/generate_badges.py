#!/usr/bin/env python3
"""Create status badges for README files."""

import argparse
import json
import sys
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from defibrillator.repo_catalog import load_all_repos

BADGE_BASE = "https://img.shields.io/badge"


def generate_badge(label: str, message: str, color: str) -> str:
    """Generate a shields.io badge URL.

    Args:
        label: Badge label
        message: Badge message
        color: Badge color

    Returns:
        Badge markdown string
    """
    encoded_label = label.replace("-", "--").replace("_", "__")
    encoded_message = message.replace("-", "--").replace("_", "__")

    url = f"{BADGE_BASE}/{encoded_label}-{encoded_message}-{color}"
    return f"![{label}]({url})"


def calculate_color(status: str) -> str:
    """Calculate badge color based on status.

    Args:
        status: Status string

    Returns:
        Color name
    """
    color_map = {
        "active": "brightgreen",
        "life-support": "yellow",
        "archived": "lightgrey",
        "pending": "blue",
        "unknown": "grey",
        "passing": "brightgreen",
        "failing": "red",
    }

    return color_map.get(status, "lightgrey")


def calculate_arch_color(arch: str, archs: list[str]) -> str:
    """Calculate architecture badge color.

    Args:
        arch: Architecture name
        archs: List of supported architectures

    Returns:
        Color name
    """
    return "brightgreen" if arch in archs else "lightgrey"


def days_since_color(days: int | None) -> str:
    """Calculate color based on days since last update.

    Args:
        days: Days since last update

    Returns:
        Color name
    """
    if days is None:
        return "lightgrey"
    if days < 30:
        return "brightgreen"
    if days < 60:
        return "yellow"
    return "red"


def generate_repo_badges(data: dict[str, Any]) -> dict[str, str]:
    """Generate badges for a repository.

    Args:
        data: Repository YAML data

    Returns:
        Dictionary of badge names to markdown strings
    """
    badges = {}

    status = data.get("status", {})
    targets = data.get("targets", {})

    state = status.get("state", "unknown")
    ci_status = status.get("ci_status", "unknown")
    last_touched = status.get("last_touched", "")
    archs = targets.get("architectures", [])

    badges["status"] = generate_badge("status", state, calculate_color(state))

    badges["ci"] = generate_badge("CI", ci_status, calculate_color(ci_status))

    if last_touched:
        try:
            touched_date = datetime.strptime(last_touched, "%Y-%m-%d").replace(tzinfo=UTC)
            days = (datetime.now(UTC) - touched_date).days
            badges["last-touched"] = generate_badge("last touched", f"{days} days ago", days_since_color(days))
        except ValueError:
            pass

    for arch in ["amd64", "arm64"]:
        badges[f"arch-{arch}"] = generate_badge(arch, arch, calculate_arch_color(arch, archs))

    return badges


def generate_badges_markdown(badges: dict[str, str]) -> str:
    """Generate markdown with all badges.

    Args:
        badges: Dictionary of badge names to markdown strings

    Returns:
        Markdown string with badges
    """
    badge_order = ["status", "ci", "last-touched", "arch-amd64", "arch-arm64"]

    lines = []
    for key in badge_order:
        if key in badges:
            lines.append(badges[key])

    return " ".join(lines)


def generate_readme_content(repo_name: str, badges: str) -> str:
    """Generate README content with badges.

    Args:
        repo_name: Repository name
        badges: Badges markdown string

    Returns:
        README content
    """
    return f"""# {repo_name}

{badges}

This repository is maintained by IroncladSalvage.

## Status

- Status: See badge above
- CI: See badge above
- Last Touched: See badge above

---

*Badges generated by defibrillator*
"""


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Create status badges for README files.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--repos-dir",
        type=Path,
        default=Path(__file__).parent.parent / "repos",
        help="Directory containing repository YAML files",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path(__file__).parent.parent / "outputs" / "badges",
        help="Directory to output badge READMEs",
    )
    parser.add_argument(
        "--file",
        type=str,
        default=None,
        help="Specific repo file to process (default: all repos)",
    )

    args = parser.parse_args()

    if not args.repos_dir.exists():
        print(f"Error: repos directory not found: {args.repos_dir}", file=sys.stderr)
        return 2

    repo_data = load_all_repos(args.repos_dir)

    if args.file:
        repo_data = [r for r in repo_data if r.get("_file") == args.file]

    if not repo_data:
        print("No repository files found.")
        return 0

    args.output_dir.mkdir(parents=True, exist_ok=True)

    for data in repo_data:
        file_stem = data.get("_file", "unknown")
        fork = data.get("fork", {})

        repo_name = fork.get("name", file_stem)

        badges = generate_repo_badges(data)
        badges_markdown = generate_badges_markdown(badges)
        readme_content = generate_readme_content(repo_name, badges_markdown)

        output_file = args.output_dir / f"{file_stem}.md"
        output_file.write_text(readme_content, encoding="utf-8")

        print(f"Generated: {output_file}")

        json_file = args.output_dir / f"{file_stem}.badges.json"
        json_file.write_text(json.dumps(badges, indent=2), encoding="utf-8")

    print(f"\nProcessed {len(repo_data)} repository file(s).")
    print(f"Output directory: {args.output_dir}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
